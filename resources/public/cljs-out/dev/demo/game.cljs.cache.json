["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$demo.game","~:imports",null,"~:requires",["^ ","~$s","~$clojure.set","^9","^9"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$transformations",["^ ","^5","~$demo.game/transformations","~:file","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","~:line",5,"~:column",1,"~:end-line",5,"~:end-column",21,"~:meta",["^ ","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^@",5,"^A",6,"^B",5,"^C",21],"~:tag",["^4",[null,"~$any"]]],"~$alive?",["^ ","~:protocol-inline",null,"^D",["^ ","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^@",10,"^A",7,"^B",10,"^C",13,"~:arglists",["~#list",["~$quote",["^J",[["~$cells","~$key"]]]]],"~:doc","Checks whether the key is in the cells"],"^5","~$demo.game/alive?","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^C",13,"~:method-params",["^J",[["^L","^M"]]],"~:protocol-impl",null,"~:arglists-meta",["^J",[null,null]],"^A",1,"~:variadic?",false,"^@",10,"~:ret-tag","~$boolean","^B",10,"~:max-fixed-arity",2,"~:fn-var",true,"^I",["^J",["^K",["^J",[["^L","^M"]]]]],"^N","Checks whether the key is in the cells"],"~$get-neighbours",["^ ","^H",null,"^D",["^ ","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^@",15,"^A",7,"^B",15,"^C",21,"^I",["^J",["^K",["^J",[["^M"]]]]],"^N","Returns the keys of nearby cells"],"^5","~$demo.game/get-neighbours","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^C",21,"^P",["^J",[["^M"]]],"^Q",null,"^R",["^J",[null,null]],"^A",1,"^S",false,"^@",15,"^T","~$cljs.core/LazySeq","^B",15,"^V",1,"^W",true,"^I",["^J",["^K",["^J",[["^M"]]]]],"^N","Returns the keys of nearby cells"],"~$possible-alive",["^ ","^H",null,"^D",["^ ","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^@",20,"^A",7,"^B",20,"^C",21,"^I",["^J",["^K",["^J",[["^L"]]]]],"^N","Given the current state it returns a list of candidates that could posiibly be alive in the next iteration"],"^5","~$demo.game/possible-alive","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^C",21,"^P",["^J",[["^L"]]],"^Q",null,"^R",["^J",[null,null]],"^A",1,"^S",false,"^@",20,"^T",["^4",[null,"^F"]],"^B",20,"^V",1,"^W",true,"^I",["^J",["^K",["^J",[["^L"]]]]],"^N","Given the current state it returns a list of candidates that could posiibly be alive in the next iteration"],"~$should-live?",["^ ","^H",null,"^D",["^ ","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^@",28,"^A",7,"^B",28,"^C",19,"^I",["^J",["^K",["^J",[["~$state","^M"]]]]],"^N","Using the key and the state this function checks whether the cell should be alive or dead in the next iteration"],"^5","~$demo.game/should-live?","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^C",19,"^P",["^J",[["^12","^M"]]],"^Q",null,"^R",["^J",[null,null]],"^A",1,"^S",false,"^@",28,"^T","^U","^B",28,"^V",2,"^W",true,"^I",["^J",["^K",["^J",[["^12","^M"]]]]],"^N","Using the key and the state this function checks whether the cell should be alive or dead in the next iteration"],"~$update-cells",["^ ","^H",null,"^D",["^ ","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^@",43,"^A",7,"^B",43,"^C",19,"^I",["^J",["^K",["^J",[["^12","~$possible"]]]]]],"^5","~$demo.game/update-cells","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^C",19,"^P",["^J",[["^12","^15"]]],"^Q",null,"^R",["^J",[null,null]],"^A",1,"^S",false,"^@",43,"^T",["^4",[null,"~$clj","^F"]],"^B",43,"^V",2,"^W",true,"^I",["^J",["^K",["^J",[["^12","^15"]]]]]],"~$next-state",["^ ","^H",null,"^D",["^ ","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^@",47,"^A",7,"^B",47,"^C",17,"^I",["^J",["^K",["^J",[["^12"]]]]],"^N","Produces the next state"],"^5","~$demo.game/next-state","^?","/home/espen/MEGAsync/code/clojure/demo/src/demo/game.cljs","^C",17,"^P",["^J",[["^12"]]],"^Q",null,"^R",["^J",[null,null]],"^A",1,"^S",false,"^@",47,"^T",["^4",["^17","^F"]],"^B",47,"^V",1,"^W",true,"^I",["^J",["^K",["^J",[["^12"]]]]],"^N","Produces the next state"]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:size","~:round","~:cells"]],"~:order",["^1>","^1@","^1?"]],"^N",null]